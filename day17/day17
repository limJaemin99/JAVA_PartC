##day17

## 5/12에는 ArrayList를 배열과 비교해서 사용해봤습니다.
	더 자세한것은 인터페이스 진도 후에 하겠습니다.
--------------------------------------------------------------------------------------------------------------
# 인터페이스
※ 인터페이스의 동작 방식은 상속과 비슷하게 생각하면 된다

- 인터페이스는 추상클래스와 비슷하게 추상메소드를 갖는것이 핵심이다.
	● 즉, 동작(메소드)에만 중점을 둔 다형성이다.
	
- implements 키워드를 사용한다.

- 부모에 종속되는 상속과는 다르게 여러개의 인터페이스를 사용해 구현할 수 있다.
	● 인터페이스는 [다중구현](implement), 일반 상속은 [단일상속](extends)이다.
	● 인터페이스는 '사용한다'의 개념으로 이해하면 된다. (상속은 부모에게 종속된다(위에서 설명함))

※ 상속은 한 부모에 여러 자녀, 인터페이스는 각 인터페이스에서 필요한메소드나 필드를 원하는것들만 골라서 사용하는 것

- 추상 클래스와 동일하게 객체를 직접 생성하지 않는다. (new연산 X)

- 형식
	● 필드는 상수만 있다. (public static final을 생략한다. 인스턴스 필드 없다.)
	● 추상메소드를 갖고있다. (public abstract를 생략한다.)
	● static 메소드와 인스턴스메소드(반드시 키워드 default 사용) 를 사용할 수 있다. (접근한정자는 모두 public이다.)
		//★★★ 접근한정자의 default와 다르다 (인스턴스 메소드를 나타낸다) ★★★
		
- InterfaceA를 상속받은 InterfaceAB를 정의하는것도 가능하다. (인터페이스 ▶ 인터페이스 상속 가능하다)
	● 이때 InterfaceAB를 구현한 클래스는 InterfaceA, InterfaceAB의 추상메소드를 모두 정의해야 한다.
		ex) BeAble을 Cook,Think,Run 인터페이스들에 extends한 예시
		 
★★★★★중요★★★★★	(바로 위 설명)
// 1) 필드는 상수만 있다.
// 2) 추상메소드를 갖고있다.
// 3) static 메소드 사용 가능하다.
// 4) 인스턴스메소드(반드시 키워드 default 사용) 를 사용할 수 있다.
--------------------------------------------------------------------------------------------------------------
인터페이스는 자바에서 클래스와 클래스 간의 상호작용을 정의하기 위한 추상화된 개념이다.

1.추상화: 인터페이스는 일종의 추상화된 클래스로, 메소드들의 시그니처(이름, 매개변수, 반환값)를 정의하지만 구현 내용은 포함하지 않는다.
		내용은 구현클래스에서 작성한다.
		
2.다중 상속: 클래스는 다중 상속을 할 수 없지만, 인터페이스는 다중 상속이 가능하다.
			클래스는 하나의 클래스만 상속받을 수 있지만, 여러 개의 인터페이스를 구현할 수 있다.
			
3.클래스와 인터페이스의 관계: 클래스가 인터페이스를 구현할 때는 implements 키워드를 사용한다.
						클래스는 인터페이스의 모든 메소드를 구현해야 한다. (추상클래스 상속과 동일)
						인터페이스는 클래스에 대한 다형성(Casting)을 지원하며, 여러 클래스를 하나의 인터페이스로 관리할 수 있다.
						
4.상수와 메소드: 인터페이스는 상수와 메소드를 가질 수 있다.
				상수는 public static final가 생략된 상태로 선언되고, 추상메소드는 public abstract가 생략된 상태로 선언된다.
				default메소드와 static 메소드를 사용할 수 있다.
				(여기서 default는 인스턴스 메소드를 나타낸다. 접근한정자의 default와 다르다)

5.인터페이스의 활용: 인터페이스는 다형성(Casting)과 결합도(Coupling) 감소 등의 장점을 제공하며, 코드의 재사용성과 확장성을 높일 수 있다.
				인터페이스를 사용하여 클래스 간의 관계를 유연하게 설계할 수 있고, 인터페이스를 구현하는 클래스들은 일관된 동작을 보장받을 수 있다.
				인터페이스는 코드의 유연성과 재사용성을 높이는 데 중요한 역할을 한다.
				
				※결합도(Coupling) : 모듈 간의 상호 의존 정도
				※모듈화(Modularization) : 소프트웨어를 각 기능별로 나누는 것
				※모듈(Module) : 각각의 기능별로 나눠진 모듈화의 결과
--------------------------------------------------------------------------------------------------------------
# Comparable<T>
- Comparable<T>는 compareTo를 사용하기 위해 implements 하여 사용하는 인터페이스이다.
	● <T> 는  제너릭 타입으로 설정한다.
     	ex) public class Member implements Comparable<Member>{ ... }

- 고정된 필드로 compareTo를 미리 코드에 작성해야하며, 정렬 필드를 변경하려면 하드코딩으로 변경해줘야 한다.

- 사용할 클래스에 implements 했다면 Comparable<Member> 인터페이스의 추상메소드를 정의해줘야한다.
     	ex) public int compareTo(Member o){
          		return this.name.compareTo(o.getName());	//name기준으로 sort할 경우
          	}
- this.name 과 o.getName의 위치를 바꾸면 내림차순

- compareTo가 재정의된 클래스의 객체를 sort할 경우 무조건 compareTo에서 비교한 변수를 기준으로 오름/내림차순 정렬된다.
		//comparator 인터페이스로 sort 실행 시점에서 필드를 결정할 수 있게 변경한다.


- compareTo로 int 값을 비교할 경우 ▶ [값1].compareTo([값2]) : 값1-값2
- compareTo로 String값을 비교할 경우 ▶ [값1].compareTo([값2]) : (사전에서의 순서를 기준으로) 값1-값2
	※만약 compareTo로 String값을 비교하는데, 기준값에 비교대상이 포함되어있을 경우
		▶ String str = "abcd";
	  	  str.compareTo("a");  //3
	   	 str.compareTo("ab") //2
			...
	위와 같이 기준값에 비교대상이 포함되어 있을 겨우 서로의 문자열 길이의 차이값을 리턴한다.